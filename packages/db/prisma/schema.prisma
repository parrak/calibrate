generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
  engineType    = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model AmazonCompetitivePrice {
  id               String   @id @default(cuid())
  asin             String
  marketplaceId    String
  lowestPriceCents Int?
  buyBoxPriceCents Int?
  offerCount       Int      @default(0)
  data             Json?
  retrievedAt      DateTime @default(now()) @db.Timestamptz(6)

  @@index([asin, marketplaceId], map: "AmazonCompetitivePrice_asin_marketplace_idx")
  @@index([retrievedAt])
}

model AmazonIntegration {
  id             String    @id @default(cuid())
  projectId      String
  sellerId       String
  marketplaceId  String    @default("ATVPDKIKX0DER")
  region         String    @default("us-east-1")
  refreshToken   String
  accessToken    String?
  tokenExpiresAt DateTime?
  installedAt    DateTime  @default(now())
  isActive       Boolean   @default(true)
  lastSyncAt     DateTime?
  syncStatus     String?
  syncError      String?
  Project        Project   @relation(fields: [projectId], references: [id])

  @@unique([projectId, sellerId])
  @@index([projectId])
  @@index([sellerId])
}

model AmazonWatchlist {
  asin          String
  marketplaceId String
  active        Boolean  @default(true)
  notes         String?
  addedAt       DateTime @default(now()) @db.Timestamptz(6)
  updatedAt     DateTime @default(now()) @db.Timestamptz(6)

  @@id([asin, marketplaceId])
  @@unique([asin, marketplaceId], map: "AmazonWatchlist_asin_marketplace_unique")
}

model Competitor {
  id                String              @id @default(cuid())
  tenantId          String
  projectId         String
  name              String
  domain            String
  channel           String
  isActive          Boolean             @default(true)
  lastChecked       DateTime?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime
  Project           Project             @relation(fields: [projectId], references: [id])
  Tenant            Tenant              @relation(fields: [tenantId], references: [id])
  CompetitorProduct CompetitorProduct[]

  @@index([tenantId, projectId])
}

model CompetitorPrice {
  id                String            @id @default(cuid())
  productId         String
  amount            Int
  currency          String
  channel           String?
  isOnSale          Boolean           @default(false)
  saleEndsAt        DateTime?
  stockStatus       String?
  createdAt         DateTime          @default(now())
  CompetitorProduct CompetitorProduct @relation(fields: [productId], references: [id])

  @@index([createdAt])
  @@index([productId, createdAt])
}

model CompetitorProduct {
  id              String            @id @default(cuid())
  competitorId    String
  skuId           String?
  name            String
  skuCode         String?
  url             String
  imageUrl        String?
  isActive        Boolean           @default(true)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime
  CompetitorPrice CompetitorPrice[]
  Competitor      Competitor        @relation(fields: [competitorId], references: [id])
  Sku             Sku?              @relation(fields: [skuId], references: [id])

  @@index([competitorId, skuCode])
}

model CompetitorRule {
  id          String   @id @default(cuid())
  tenantId    String
  projectId   String
  name        String
  description String?
  isActive    Boolean  @default(true)
  rules       Json
  createdAt   DateTime @default(now())
  updatedAt   DateTime
  Project     Project  @relation(fields: [projectId], references: [id])
  Tenant      Tenant   @relation(fields: [tenantId], references: [id])

  @@index([tenantId, projectId])
}

model Customer {
  id        String   @id @default(cuid())
  tenantId  String
  email     String
  name      String?
  org       String?
  createdAt DateTime @default(now())
  Tenant    Tenant   @relation(fields: [tenantId], references: [id])
  Quote     Quote[]
}

model DiscountPolicy {
  id        String   @id @default(cuid())
  tenantId  String
  projectId String
  type      String // M0.1: policy type (percentage, absolute, tiered, etc.)
  ruleJson  Json // M0.1: rule definition
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  Tenant    Tenant   @relation(fields: [tenantId], references: [id])
  Project   Project  @relation(fields: [projectId], references: [id])

  @@index([tenantId, projectId, enabled])
}

model Audit {
  id        String   @id @default(cuid())
  tenantId  String
  projectId String?
  entity    String // M0.1: entity type (Product, PriceChange, etc.)
  entityId  String // M0.1: entity ID
  action    String // M0.1: action (create, update, apply, rollback, etc.)
  actor     String // M0.1: user/system actor
  explain   Json? // M0.1: explainability trace
  createdAt DateTime @default(now())
  Tenant    Tenant   @relation(fields: [tenantId], references: [id])
  Project   Project? @relation(fields: [projectId], references: [id])

  @@index([tenantId, entity, entityId])
  @@index([createdAt])
  @@index([actor])
}

model Event {
  id        String   @id @default(cuid())
  tenantId  String?
  projectId String?
  kind      String // Legacy field - kept for backward compat
  type      String? // M0.1: renamed from 'kind'
  payload   Json
  createdAt DateTime @default(now())
  Project   Project? @relation(fields: [projectId], references: [id])
  Tenant    Tenant?  @relation(fields: [tenantId], references: [id])

  @@index([kind])
  @@index([type])
  @@index([createdAt])
}

/// Event Log — Append-only event store for audit and replay
/// Supports idempotent dedupe via eventKey + tenantId
model EventLog {
  id            String   @id @default(cuid())
  eventKey      String // Idempotency key (tenant scoped)
  tenantId      String
  projectId     String?
  eventType     String // e.g., "shopify.sync.product", "pricechange.applied"
  payload       Json
  metadata      Json? // Additional context (correlationId, userId, etc.)
  correlationId String? // For tracing across services
  createdAt     DateTime @default(now()) @db.Timestamptz(6)
  version       Int      @default(1)

  @@unique([eventKey, tenantId], name: "EventLog_eventKey_tenantId_unique")
  @@index([tenantId, eventType, createdAt])
  @@index([correlationId])
  @@index([createdAt])
}

/// Outbox — Transactional outbox pattern for reliable event delivery
/// Events are inserted here in the same transaction as domain changes
model Outbox {
  id          String       @id @default(cuid())
  eventLogId  String // Reference to EventLog
  tenantId    String
  eventType   String
  payload     Json
  status      OutboxStatus @default(PENDING)
  retryCount  Int          @default(0)
  maxRetries  Int          @default(5)
  nextRetryAt DateTime?    @db.Timestamptz(6)
  lastError   String?
  processedAt DateTime?    @db.Timestamptz(6)
  createdAt   DateTime     @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime     @updatedAt @db.Timestamptz(6)

  @@index([status, nextRetryAt])
  @@index([tenantId, status])
  @@index([createdAt])
}

/// Dead Letter Queue — Failed events after max retries exceeded
model DlqEventLog {
  id            String   @id @default(cuid())
  originalId    String // Original outbox or event ID
  eventKey      String
  tenantId      String
  projectId     String?
  eventType     String
  payload       Json
  metadata      Json?
  failureReason String
  retryCount    Int
  failedAt      DateTime @default(now()) @db.Timestamptz(6)

  @@index([tenantId, eventType])
  @@index([failedAt])
}

enum OutboxStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
}

model Membership {
  id        String      @id @default(cuid())
  userId    String
  projectId String
  role      ProjectRole @default(VIEWER)
  Project   Project     @relation(fields: [projectId], references: [id])
  User      User        @relation(fields: [userId], references: [id])

  @@unique([userId, projectId])
}

model Policy {
  id        String   @id @default(cuid())
  tenantId  String
  projectId String   @unique
  autoApply Boolean  @default(false)
  rules     Json
  createdAt DateTime @default(now())
  updatedAt DateTime
  Project   Project  @relation(fields: [projectId], references: [id])
  Tenant    Tenant   @relation(fields: [tenantId], references: [id])
}

model Price {
  id           String         @id @default(cuid())
  skuId        String
  currency     String
  billingCycle String?
  unit         String?
  amount       Int
  status       Status         @default(ACTIVE)
  Sku          Sku            @relation(fields: [skuId], references: [id])
  PriceVersion PriceVersion[]

  @@unique([skuId, currency], map: "skuId_currency")
  @@index([skuId, currency])
}

model PriceChange {
  id              String             @id @default(cuid())
  tenantId        String
  projectId       String
  skuId           String
  source          String
  fromAmount      Int
  toAmount        Int
  currency        String
  context         Json?
  status          PriceChangeStatus  @default(PENDING) // Legacy field - kept for backward compat
  policyResult    Json?
  approvedBy      String?
  appliedAt       DateTime?
  connectorStatus Json?
  createdAt       DateTime           @default(now())
  // M0.1 fields (optional for now to maintain compatibility)
  selectorJson    Json? // M0.1: rule selector predicate
  transformJson   Json? // M0.1: transform (%, absolute, floor/ceiling)
  scheduleAt      DateTime? // M0.1: optional scheduling
  state           PriceChangeStatus? // M0.1: renamed from status
  createdBy       String? // M0.1: actor tracking
  Project         Project            @relation(fields: [projectId], references: [id])
  Tenant          Tenant             @relation(fields: [tenantId], references: [id])
  ExplainTrace    ExplainTrace[] // M1.1: explainability traces

  @@index([tenantId, projectId, status])
  @@index([scheduleAt])
}

/// Explain Trace — M1.1: Explainability traces for price changes
/// Stores detailed reasoning for previews, applies, and rollbacks
model ExplainTrace {
  id            String       @id @default(cuid())
  tenantId      String
  projectId     String?
  priceChangeId String? // Optional: link to specific price change
  entity        String // Entity type (PriceChange, Rule, etc.)
  entityId      String // Entity ID
  action        String // Action (preview, apply, rollback, simulate)
  actor         String // User or system actor
  trace         Json // M1.1: explainability trace (why/how)
  metadata      Json? // Additional context
  createdAt     DateTime     @default(now())
  Tenant        Tenant       @relation(fields: [tenantId], references: [id])
  Project       Project?     @relation(fields: [projectId], references: [id])
  PriceChange   PriceChange? @relation(fields: [priceChangeId], references: [id])

  @@index([tenantId, entity, entityId])
  @@index([priceChangeId])
  @@index([createdAt])
  @@index([actor])
}

model PriceVersion {
  id         String    @id @default(cuid())
  priceId    String
  amount     Int
  note       String?
  createdAt  DateTime  @default(now())
  Price      Price     @relation(fields: [priceId], references: [id])
  // M0.1 fields (optional for now)
  productId  String? // M0.1: direct product link
  currency   String? // M0.1: currency code
  unitAmount Int? // M0.1: price in smallest currency unit
  compareAt  Int? // M0.1: optional compare-at price
  validFrom  DateTime? // M0.1: version validity start
  validTo    DateTime? // M0.1: optional validity end
  Product    Product?  @relation(fields: [productId], references: [id])

  @@index([priceId])
  @@index([productId, validFrom, validTo])
  @@index([currency])
}

model Product {
  id           String         @id @default(cuid())
  tenantId     String
  projectId    String
  name         String
  code         String
  status       Status         @default(DRAFT)
  createdAt    DateTime       @default(now())
  // M0.1 fields (optional for backward compat)
  sku          String? // M0.1: canonical SKU
  title        String? // M0.1: product title
  tags         String[]       @default([]) // M0.1: array of tags
  channelRefs  Json? // M0.1: connector-specific refs
  active       Boolean?       @default(true) // M0.1: active status
  Project      Project        @relation(fields: [projectId], references: [id])
  Tenant       Tenant         @relation(fields: [tenantId], references: [id])
  Sku          Sku[]
  PriceVersion PriceVersion[]

  @@unique([tenantId, projectId, code], map: "tenantId_projectId_code")
  @@unique([tenantId, projectId, sku], map: "tenantId_projectId_sku")
  @@index([tenantId, active])
  @@index([tags])
}

model Project {
  id                 String               @id @default(cuid())
  tenantId           String
  name               String
  slug               String               @unique
  createdAt          DateTime             @default(now())
  updatedAt          DateTime
  amazonIntegrations String[]
  AmazonIntegration  AmazonIntegration[]
  Competitor         Competitor[]
  CompetitorRule     CompetitorRule[]
  Event              Event[]
  Membership         Membership[]
  Policy             Policy?
  Product            Product[]
  Tenant             Tenant               @relation(fields: [tenantId], references: [id])
  ShopifyIntegration ShopifyIntegration[]
  Audit              Audit[] // M0.1
  DiscountPolicy     DiscountPolicy[] // M0.1
  PriceChange        PriceChange[] // M0.1
  ExplainTrace       ExplainTrace[] // M1.1
  CopilotQueryLog    CopilotQueryLog[] // M1.4
}

model Quote {
  id          String      @id @default(cuid())
  tenantId    String
  customerId  String
  status      QuoteStatus @default(DRAFT)
  currency    String
  subtotal    Int         @default(0)
  total       Int         @default(0)
  meta        Json?
  createdAt   DateTime    @default(now())
  checkoutUrl String?
  Customer    Customer    @relation(fields: [customerId], references: [id])
  QuoteItem   QuoteItem[]
}

model QuoteItem {
  id         String   @id @default(cuid())
  quoteId    String
  skuId      String
  name       String
  qty        Int
  unitAmount Int
  createdAt  DateTime @default(now())
  Quote      Quote    @relation(fields: [quoteId], references: [id])
}

model ShopifyIntegration {
  id                         String                       @id @default(cuid())
  projectId                  String
  shopDomain                 String                       @unique
  accessToken                String
  scope                      String
  installedAt                DateTime                     @default(now())
  isActive                   Boolean                      @default(true)
  lastSyncAt                 DateTime?
  syncStatus                 String?
  syncError                  String?
  Project                    Project                      @relation(fields: [projectId], references: [id])
  ShopifyWebhookSubscription ShopifyWebhookSubscription[]

  @@index([projectId])
  @@index([shopDomain])
}

model ShopifyWebhookSubscription {
  id                 String             @id @default(cuid())
  integrationId      String
  topic              String
  address            String
  webhookId          String             @unique
  createdAt          DateTime           @default(now())
  isActive           Boolean            @default(true)
  ShopifyIntegration ShopifyIntegration @relation(fields: [integrationId], references: [id])

  @@index([integrationId])
  @@index([webhookId])
}

model Sku {
  id                String              @id @default(cuid())
  productId         String
  name              String
  code              String
  attributes        Json?
  status            Status              @default(DRAFT)
  CompetitorProduct CompetitorProduct[]
  Price             Price[]
  Product           Product             @relation(fields: [productId], references: [id])

  @@unique([productId, code], map: "productId_code")
}

model Tenant {
  id              String            @id @default(cuid())
  name            String
  createdAt       DateTime          @default(now())
  Competitor      Competitor[]
  CompetitorRule  CompetitorRule[]
  Customer        Customer[]
  Event           Event[]
  Policy          Policy[]
  Product         Product[]
  Project         Project[]
  User            User[]
  Audit           Audit[] // M0.1
  DiscountPolicy  DiscountPolicy[] // M0.1
  PriceChange     PriceChange[] // M0.1
  ExplainTrace    ExplainTrace[] // M1.1
  CopilotQueryLog CopilotQueryLog[] // M1.4
}

model User {
  id           String       @id @default(cuid())
  email        String       @unique
  name         String?
  role         Role         @default(MEMBER)
  tenantId     String
  createdAt    DateTime     @default(now())
  passwordHash String?
  Membership   Membership[]
  Tenant       Tenant       @relation(fields: [tenantId], references: [id])
}

enum PriceChangeStatus {
  PENDING
  APPROVED
  REJECTED
  APPLIED
  FAILED
  ROLLED_BACK
}

enum ProjectRole {
  OWNER
  ADMIN
  EDITOR
  VIEWER
}

enum QuoteStatus {
  DRAFT
  ISSUED
  ACCEPTED
  EXPIRED
}

enum Role {
  OWNER
  ADMIN
  MEMBER
}

enum Status {
  DRAFT
  ACTIVE
  ARCHIVED
}

/// CopilotQueryLog — M1.4: Audit trail for copilot queries
/// Logs all natural language queries with resolved schemas and tenant scope
model CopilotQueryLog {
  id             String   @id @default(cuid())
  tenantId       String
  projectId      String
  userId         String? // User who made the query
  userRole       String? // Role at time of query (VIEWER, EDITOR, ADMIN, OWNER)
  query          String // Natural language query
  generatedSQL   String? // Generated SQL query
  queryType      String // Type: 'read', 'aggregate', 'explain'
  resultCount    Int? // Number of results returned
  executionTime  Int? // Execution time in ms
  schemaVersion  String? // Schema version used for query generation
  method         String? // 'ai' or 'pattern'
  success        Boolean @default(true)
  error          String? // Error message if failed
  metadata       Json? // Additional context (filters, params, etc.)
  createdAt      DateTime @default(now()) @db.Timestamptz(6)
  Tenant         Tenant   @relation(fields: [tenantId], references: [id])
  Project        Project  @relation(fields: [projectId], references: [id])

  @@index([tenantId, projectId, createdAt])
  @@index([userId, createdAt])
  @@index([success])
  @@index([createdAt])
}

/// AnalyticsDigest — M1.4: Daily analytics snapshots with anomaly detection
/// Stores aggregated metrics and detected anomalies for pricing intelligence
model AnalyticsDigest {
  id                    String   @id @default(cuid())
  tenantId              String
  projectId             String
  digestDate            DateTime @db.Date // Date of the digest
  totalPriceChanges     Int      @default(0)
  totalRevenue          Int? // Projected revenue impact in cents
  avgMargin             Float? // Average margin percentage
  anomalies             Json? // Detected anomalies: price spikes, margin compression
  topPerformers         Json? // Top performing SKUs
  metrics               Json // Additional metrics
  createdAt             DateTime @default(now()) @db.Timestamptz(6)

  @@unique([projectId, digestDate])
  @@index([tenantId, projectId, digestDate])
  @@index([digestDate])
}
