generator client {
  provider = "prisma-client-js"
  // Target both native (for local dev) and Debian Slim (for Railway deployment)
  binaryTargets = ["native", "debian-openssl-3.0.x"]
  engineType   = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Tenant {
  id        String   @id @default(cuid())
  name      String
  users     User[]
  projects  Project[]
  products  Product[]
  customers Customer[]
  policies  Policy[]
  events    Event[]
  competitors Competitor[]
  competitorRules CompetitorRule[]
  createdAt DateTime @default(now())
}

model User {
  id          String       @id @default(cuid())
  email       String       @unique
  name        String?
  role        Role         @default(MEMBER)
  tenantId    String
  tenant      Tenant       @relation(fields: [tenantId], references: [id])
  memberships Membership[]
  createdAt   DateTime     @default(now())
}

enum Role {
  OWNER
  ADMIN
  MEMBER
}

model Project {
  id          String        @id @default(cuid())
  tenantId    String
  tenant      Tenant        @relation(fields: [tenantId], references: [id])
  name        String
  slug        String        @unique
  memberships Membership[]
  products    Product[]
  policies    Policy[]
  events      Event[]
  competitors Competitor[]
  competitorRules CompetitorRule[]
  shopifyIntegrations ShopifyIntegration[]
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt
}

model Membership {
  id        String      @id @default(cuid())
  userId    String
  projectId String
  role      ProjectRole @default(VIEWER)
  user      User        @relation(fields: [userId], references: [id])
  project   Project     @relation(fields: [projectId], references: [id])

  @@unique([userId, projectId])
}

enum ProjectRole {
  OWNER
  ADMIN
  EDITOR
  VIEWER
}

model Product {
  id        String   @id @default(cuid())
  tenantId  String
  projectId String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  project   Project  @relation(fields: [projectId], references: [id])
  name      String
  code      String
  status    Status   @default(DRAFT)
  skus      Sku[]
  createdAt DateTime @default(now())

  // Allow upserts by (tenantId, projectId, code) as used in seed scripts
  @@unique([tenantId, projectId, code], name: "tenantId_projectId_code")
}

enum Status {
  DRAFT
  ACTIVE
  ARCHIVED
}

model Sku {
  id         String   @id @default(cuid())
  productId  String
  product    Product  @relation(fields: [productId], references: [id])
  name       String
  code       String
  attributes Json?
  status     Status   @default(DRAFT)
  prices     Price[]
  competitorProducts CompetitorProduct[]

  // Allow upserts by (productId, code) as used in seed scripts
  @@unique([productId, code], name: "productId_code")
}

model Price {
  id           String         @id @default(cuid())
  skuId        String
  sku          Sku            @relation(fields: [skuId], references: [id])
  currency     String
  billingCycle String?
  unit         String?
  amount       Int
  status       Status         @default(ACTIVE)
  versions     PriceVersion[]

  // Ensure upserts by (skuId, currency) work in seed scripts
  @@unique([skuId, currency], name: "skuId_currency")
}

model PriceVersion {
  id        String   @id @default(cuid())
  priceId   String
  price     Price    @relation(fields: [priceId], references: [id])
  amount    Int
  note      String?
  createdAt DateTime @default(now())
}

model Policy {
  id        String   @id @default(cuid())
  tenantId  String
  projectId String   @unique
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  project   Project  @relation(fields: [projectId], references: [id])
  autoApply Boolean  @default(false)
  rules     Json     // {maxPctDelta, dailyChangeBudgetPct, floors, ceilings}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model PriceChange {
  id           String            @id @default(cuid())
  tenantId     String
  projectId    String
  skuId        String
  source       String
  fromAmount   Int
  toAmount     Int
  currency     String
  context      Json?
  status       PriceChangeStatus @default(PENDING)
  policyResult Json?
  approvedBy   String?
  appliedAt    DateTime?
  createdAt    DateTime          @default(now())

  @@index([tenantId, projectId, status])
}

enum PriceChangeStatus {
  PENDING
  APPROVED
  REJECTED
  APPLIED
  FAILED
  ROLLED_BACK
}

model Customer {
  id        String   @id @default(cuid())
  tenantId  String
  tenant    Tenant   @relation(fields: [tenantId], references: [id])
  email     String
  name      String?
  org       String?
  quotes    Quote[]
  createdAt DateTime @default(now())
}

model Quote {
  id          String      @id @default(cuid())
  tenantId    String
  customerId  String
  customer    Customer    @relation(fields: [customerId], references: [id])
  status      QuoteStatus @default(DRAFT)
  currency    String
  subtotal    Int         @default(0)
  total       Int         @default(0)
  meta        Json?
  createdAt   DateTime    @default(now())
  items       QuoteItem[]
  checkoutUrl String?
}

enum QuoteStatus {
  DRAFT
  ISSUED
  ACCEPTED
  EXPIRED
}

model QuoteItem {
  id         String   @id @default(cuid())
  quoteId    String
  quote      Quote    @relation(fields: [quoteId], references: [id])
  skuId      String
  name       String
  qty        Int
  unitAmount Int
  createdAt  DateTime @default(now())
}

model Event {
  id        String   @id @default(cuid())
  tenantId  String?
  projectId String?
  tenant    Tenant?  @relation(fields: [tenantId], references: [id])
  project   Project? @relation(fields: [projectId], references: [id])
  kind      String
  payload   Json
  createdAt DateTime @default(now())
}

model Competitor {
  id          String   @id @default(cuid())
  tenantId    String
  projectId   String
  tenant      Tenant   @relation(fields: [tenantId], references: [id])
  project     Project  @relation(fields: [projectId], references: [id])
  name        String
  domain      String
  channel     String   // 'shopify', 'amazon', 'google_shopping', etc.
  isActive    Boolean  @default(true)
  lastChecked DateTime?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  products    CompetitorProduct[]
  
  @@index([tenantId, projectId])
}

model CompetitorProduct {
  id           String   @id @default(cuid())
  competitorId String
  competitor   Competitor @relation(fields: [competitorId], references: [id])
  skuId        String?
  sku          Sku?     @relation(fields: [skuId], references: [id])
  name         String
  skuCode      String?  // Competitor's SKU code
  url          String
  imageUrl     String?
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  prices       CompetitorPrice[]
  
  @@index([competitorId, skuCode])
}

model CompetitorPrice {
  id           String   @id @default(cuid())
  productId    String
  product      CompetitorProduct @relation(fields: [productId], references: [id])
  amount       Int      // Price in minor units (cents)
  currency     String
  channel      String?  // Specific channel within competitor
  isOnSale     Boolean  @default(false)
  saleEndsAt   DateTime?
  stockStatus  String?  // 'in_stock', 'out_of_stock', 'limited'
  createdAt    DateTime @default(now())
  
  @@index([productId, createdAt])
  @@index([createdAt])
}

model CompetitorRule {
  id           String   @id @default(cuid())
  tenantId     String
  projectId    String
  tenant       Tenant   @relation(fields: [tenantId], references: [id])
  project      Project  @relation(fields: [projectId], references: [id])
  name         String
  description  String?
  isActive     Boolean  @default(true)
  rules        Json     // Pricing rules based on competitor data
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  
  @@index([tenantId, projectId])
}

// Amazon competitive pricing snapshot storage
model AmazonCompetitivePrice {
  id                String   @id @default(cuid())
  asin              String
  marketplaceId     String
  lowestPriceCents  Int?
  buyBoxPriceCents  Int?
  offerCount        Int      @default(0)
  data              Json?
  retrievedAt       DateTime @default(now())

  @@index([asin, marketplaceId])
  @@index([retrievedAt])
}

// Amazon watchlist of ASINs to track
model AmazonWatchlist {
  asin          String
  marketplaceId String
  active        Boolean  @default(true)
  notes         String?
  addedAt       DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@id([asin, marketplaceId])
}

model ShopifyIntegration {
  id              String   @id @default(cuid())
  projectId       String
  shopDomain      String   @unique
  accessToken     String   @db.Text
  scope           String
  installedAt     DateTime @default(now())
  isActive        Boolean  @default(true)
  lastSyncAt      DateTime?
  syncStatus      String?  // 'success', 'error', 'in_progress'
  syncError       String?  @db.Text
  webhookSubscriptions ShopifyWebhookSubscription[]

  project         Project  @relation(fields: [projectId], references: [id])

  @@index([projectId])
  @@index([shopDomain])
}

model ShopifyWebhookSubscription {
  id              String   @id @default(cuid())
  integrationId   String
  topic           String
  address         String
  webhookId       String   @unique
  createdAt       DateTime @default(now())
  isActive        Boolean  @default(true)

  integration     ShopifyIntegration @relation(fields: [integrationId], references: [id])

  @@index([integrationId])
  @@index([webhookId])
}
