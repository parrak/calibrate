name: Pull Request Lint

on:
  pull_request:
    types: [opened, edited, synchronize, reopened]

jobs:
  pr_lint:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Check PR for Railway / deployment verification
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('No pull request found in context â€” skipping.');
              return;
            }

            const prNumber = pr.number;
            core.info(`Inspecting PR #${prNumber}`);

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            const changed = files.map(f => f.filename);
            core.info(`Changed files: ${changed.join(', ')}`);

            // Patterns that indicate deployment/infra/schema changes that require replication evidence
            const infraPatterns = [
              /^apps\/.*\/DEPLOYMENT.md$/,
              /^packages\/db\//,
              /^apps\/api\//,
              /^Dockerfile$/,
              /^packages\/db\/prisma\//,
              /^\.railwayignore$/,
              /^apps\/.*\/railway.json$/,
            ];

            const infraChanged = changed.some(fn => infraPatterns.some(p => p.test(fn)));
            if (infraChanged) {
              const body = pr.body || '';
              const evidenceRegex = /pnpm verify:local|railway\b|railway up|railway logs|verification|CHANGELOG.md|Unreleased/i;
              const ok = evidenceRegex.test(body) || changed.some(f => f.endsWith('.md'));
              if (!ok) {
                const comment = `:warning: **Deployment verification missing**\n\nThis PR modifies deployment/infra files and must include local Railway replication evidence or a changelog entry.\n\nPlease update the PR body to include one of:\n- a summary of commands run (e.g. \`pnpm verify:local\`, \`railway up\`, or \`pnpm --filter @calibr/db prisma migrate deploy\`)\n- migration/build/smoke-test outputs or attach \`{branch}-railway-verify.log\`\n- a changelog entry in \`CHANGELOG.md\` under Unreleased\n\nOr add the relevant docs/DEPLOYMENT/CHANGELOG.md updates to this branch.\n\nOnce you've updated the PR, this check will pass automatically.`;
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body: comment });
                core.setFailed('PR missing Railway verification evidence or changelog/docs update.');
              } else {
                core.info('PR contains Railway verification evidence or changelog/docs update.');
              }
            } else {
              core.info('No infra/deploy-related files changed; skipping Railway verification check.');
            }

            // Enforce documentation updates for code changes: if code files were modified, require a Markdown update or changelog entry
            const codePatterns = [/\.ts$/, /\.tsx$/, /\.js$/, /\.jsx$/, /\.py$/, /\.go$/, /\.java$/, /\.rs$/, /\.cs$/];
            const codeChanged = changed.some(fn => codePatterns.some(p => p.test(fn)));
            if (codeChanged) {
              const hasMdUpdate = changed.some(f => f.endsWith('.md'));
              const body = pr.body || '';
              const changelogMention = /CHANGELOG.md|Unreleased/i.test(body);
              if (!hasMdUpdate && !changelogMention) {
                const comment2 = ':information_source: **Docs update required**\\n\\nThis PR changes source code files but does not include any Markdown documentation updates or a changelog entry.\\n\\nPlease add at least one of the following to this branch or PR body:\\n- Update CHANGELOG.md under Unreleased with a short summary\\n- Update the relevant package or app README/DEPLOYMENT.md with the change\\n- Add a small verification markdown file under .github/ describing steps you ran\\n\\nKeeping docs up to date ensures future agents and reviewers understand the context of changes.';
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body: comment2 });
                core.setFailed('PR missing documentation (Markdown) updates for code changes.');
              } else {
                core.info('PR includes Markdown docs update or changelog entry for code changes.');
              }
            } else {
              core.info('No code changes detected requiring docs updates.');
            }

            // If the PR author is an automated agent / bot, require an agent metadata JSON block in the PR body
            const prAuthor = pr.user && pr.user.login ? pr.user.login : '';
            const isBotAuthor = (pr.user && pr.user.type === 'Bot') || /bot$/i.test(prAuthor) || prAuthor.endsWith('[bot]');
            if (isBotAuthor) {
              const body = pr.body || '';
              const hasAgentMetadata = /"agent"\s*:\s*".+?"/i.test(body) && /"contextId"\s*:\s*".+?"/i.test(body) && /"timestamp"\s*:\s*".+?"/i.test(body);
              if (!hasAgentMetadata) {
                  const comment = `:warning: **Agent metadata required**\n\nThis PR appears to be authored by an automated agent (${prAuthor}). Automated agents must include a small JSON metadata block in the PR body matching the schema in .github/AGENT_METADATA_SCHEMA.md.\n\nPlease include a JSON object with at least the fields "agent", "contextId" and "timestamp" in the PR body (example: {"agent":"gpt-4o","contextId":"...","timestamp":"2025-10-25T12:34:56Z"}).\n\nOnce updated, this check will pass automatically.`;
                await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: prNumber, body: comment });
                core.setFailed('Bot-authored PR missing agent metadata in PR body.');
              } else {
                core.info('Agent metadata present for bot-authored PR.');
              }
            } else {
              core.info('PR author is not a bot; agent metadata not required.');
            }

            // Check that all review comments are resolved
            core.info('Checking for unresolved review comments...');

            // Get all review threads
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            // Get all review comments (inline code review comments)
            const { data: reviewComments } = await github.rest.pulls.listReviewComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });

            // Get all issue comments (general PR comments)
            const { data: issueComments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });

            // GitHub doesn't provide a direct "unresolved" flag, but we can check for:
            // 1. Review comments that are part of a review thread
            // 2. Check if the thread has been marked as resolved via the Resolve Conversation feature

            // GitHub's REST API doesn't expose the "resolved" status directly for review threads.
            // We need to use the GraphQL API or check for specific patterns.
            // For now, we'll use a heuristic: if there are any review comments requesting changes
            // and the latest review is not an approval, we'll flag it.

            const latestReviewByUser = new Map();
            for (const review of reviews) {
              const user = review.user?.login;
              if (user && review.submitted_at) {
                const existing = latestReviewByUser.get(user);
                if (!existing || new Date(review.submitted_at) > new Date(existing.submitted_at)) {
                  latestReviewByUser.set(user, review);
                }
              }
            }

            const unresolvedReviewers = [];
            for (const [user, review] of latestReviewByUser.entries()) {
              if (review.state === 'CHANGES_REQUESTED' || review.state === 'COMMENTED') {
                // Check if there are unresolved comments from this reviewer
                const userComments = reviewComments.filter(c => c.user?.login === user);
                if (userComments.length > 0) {
                  unresolvedReviewers.push(user);
                }
              }
            }

            // Additionally, check for review comments that are explicitly in unresolved threads
            // using GitHub's GraphQL API through github-script
            let hasUnresolvedThreads = false;
            try {
              const query = `
                query($owner: String!, $repo: String!, $prNumber: Int!) {
                  repository(owner: $owner, name: $repo) {
                    pullRequest(number: $prNumber) {
                      reviewThreads(first: 100) {
                        nodes {
                          isResolved
                          isOutdated
                          comments(first: 1) {
                            nodes {
                              author {
                                login
                              }
                              body
                            }
                          }
                        }
                      }
                    }
                  }
                }
              `;

              const result = await github.graphql(query, {
                owner: context.repo.owner,
                repo: context.repo.repo,
                prNumber: prNumber,
              });

              const threads = result.repository.pullRequest.reviewThreads.nodes;
              const unresolvedThreads = threads.filter(t => !t.isResolved && !t.isOutdated);

              if (unresolvedThreads.length > 0) {
                hasUnresolvedThreads = true;
                core.info(`Found ${unresolvedThreads.length} unresolved review thread(s)`);

                const comment3 = `:warning: **Unresolved review comments**\n\nThis PR has ${unresolvedThreads.length} unresolved review thread(s).\n\nPlease address all review comments and mark conversations as resolved before merging.\n\nTo resolve a conversation:\n1. Address the feedback by making the requested changes\n2. Click "Resolve conversation" on each review thread\n\nThis check will pass automatically once all review threads are resolved.`;
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: comment3
                });
                core.setFailed(`PR has ${unresolvedThreads.length} unresolved review thread(s).`);
              } else {
                core.info('All review threads are resolved or outdated.');
              }
            } catch (error) {
              core.warning(`Could not check review threads via GraphQL: ${error.message}`);
              // Fallback: if GraphQL fails, just log a warning but don't fail the check
              core.info('Skipping unresolved review threads check due to GraphQL error.');
            }